{% extends 'layout.html' %}

{% block content %}
<div class="row">
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header bg-primary">
                <i class="bi bi-server"></i> Managed Processes
            </div>
            <div class="card-body">
                <div class="search-container mb-3">
                    <input type="text" id="search-bar" class="form-control" placeholder="Search process..." oninput="filterProcesses()">
                    <select id="sort-select" class="form-select w-auto" onchange="sortProcesses()">
                        <option value="alpha">Alphabet (A-Z)</option>
                        <option value="alpha-reverse">Alphabet (Z-A)</option>
                        <option value="created">Created At (Oldest)</option>
                        <option value="created-reverse">Created At (Newest)</option>
                        <option value="status">Status (Ascending)</option>
                        <option value="status-reverse">Status (Descending)</option>
                    </select>
                </div>
            </div>
            <div class="table-responsive">
                <table class="table table-sticky-header">
                    <thead>
                        <tr>
                            <th>Process ID</th>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Status</th>
                            <th>CPU</th>
                            <th>Memory</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="process-grid">
                        <!-- Skeleton loader -->
                        <tr class="skeleton-row">
                            <td><div class="skeleton skeleton-text" style="width: 80px;"></div></td>
                            <td><div class="skeleton skeleton-text" style="width: 120px;"></div></td>
                            <td><div class="skeleton skeleton-text" style="width: 60px;"></div></td>
                            <td><div class="skeleton skeleton-text" style="width: 70px;"></div></td>
                            <td><div class="skeleton skeleton-text" style="width: 50px;"></div></td>
                            <td><div class="skeleton skeleton-text" style="width: 50px;"></div></td>
                            <td><div class="skeleton skeleton-button"></div></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card">
            <div class="card-header bg-success">
                <i class="bi bi-cpu"></i> System Resources
            </div>
            <div class="card-body" id="server-stats">
                <div class="progress-item">
                    <div class="progress-header">
                        <span>CPU Usage</span>
                        <span class="fw-bold"><span id="cpu-usage">Loading...</span>%</span>
                    </div>
                    <div class="progress">
                        <div class="progress-bar" id="cpu-progress" style="width: 0%"></div>
                    </div>
                    <small class="text-muted"><span id="cpu-name">Loading...</span></small>
                </div>

                <div class="progress-item">
                    <div class="progress-header">
                        <span>Memory</span>
                        <span class="fw-bold">
                            <span id="memory-used">Loading...</span> / <span id="memory-allocated">Loading...</span> MB
                        </span>
                    </div>
                    <div class="progress">
                        <div class="progress-bar bg-warning" id="memory-progress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="progress-item">
                    <div class="progress-header">
                        <span>Storage</span>
                        <span class="fw-bold">
                            <span id="storage-used">Loading...</span> / <span id="storage-allocated">Loading...</span> GB
                        </span>
                    </div>
                    <div class="progress">
                        <div class="progress-bar bg-info" id="storage-progress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="progress-item" style="margin-bottom: 0;">
                    <div class="progress-header">
                        <span>Network</span>
                        <span class="fw-bold">
                            <i class="bi bi-arrow-down" style="color: var(--accent-green);"></i> <span id="network-usage">Loading...</span> MB/s
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>

    let userSettings = null;
    let autoRefreshInterval = null;

    // Fetch user settings on page load
    async function loadUserSettings() {
        try {
            const response = await fetch("{{ url_for('settings.get_preferences') }}");
            const data = await response.json();
            userSettings = data;
            
            // If remember filters is enabled, load saved filters
            if (userSettings.remember_filters) {
                loadSavedFilters();
            }

            // Setup auto-refresh if enabled
            if (userSettings.auto_refresh_enabled) {
                setupAutoRefresh(userSettings.auto_refresh_interval);
            }
        } catch (error) {
            console.error("Failed to load user settings:", error);
        }
    }

    function setupAutoRefresh(intervalSeconds) {
        // Clear any existing interval
        if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
        }

        // Set up new interval
        autoRefreshInterval = setInterval(() => {
            fetchProcesses();
            fetchServerStats();
        }, intervalSeconds * 1000);
    }

    function loadSavedFilters() {
        const savedSearch = localStorage.getItem('dashboardSearchQuery');
        const savedSort = localStorage.getItem('dashboardSortOption');
        
        if (savedSearch !== null) {
            document.getElementById('search-bar').value = savedSearch;
        }
        
        if (savedSort !== null) {
            document.getElementById('sort-select').value = savedSort;
        }
    }

    function saveFilterSettings() {
        if (userSettings && userSettings.remember_filters) {
            const searchQuery = document.getElementById('search-bar').value;
            const sortOption = document.getElementById('sort-select').value;
            
            localStorage.setItem('dashboardSearchQuery', searchQuery);
            localStorage.setItem('dashboardSortOption', sortOption);
        }
    }

    async function fetchServerStats() {
        const response = await fetch("{{ url_for('get_server_stats') }}");
        const stats = await response.json();
        
        // Update CPU
        document.getElementById('cpu-name').textContent = stats.cpu_name;
        document.getElementById('cpu-usage').textContent = stats.cpu_usage;
        document.getElementById('cpu-progress').style.width = stats.cpu_usage + '%';
        
        // Update Memory 
        const memoryUsedMB = Math.round((stats.memory_usage / 100) * stats.memory_allocated);
        document.getElementById('memory-used').textContent = memoryUsedMB;
        document.getElementById('memory-allocated').textContent = stats.memory_allocated;
        document.getElementById('memory-progress').style.width = stats.memory_usage + '%';
        
        // Update Storage
        const storageUsedGB = Math.round((stats.storage_usage / 100) * stats.storage_allocated * 10) / 10;
        document.getElementById('storage-used').textContent = storageUsedGB;
        document.getElementById('storage-allocated').textContent = stats.storage_allocated;
        document.getElementById('storage-progress').style.width = stats.storage_usage + '%';
        
        // Update Network
        document.getElementById('network-usage').textContent = stats.network_usage;
    }
    fetchServerStats();

    function filterProcesses() {
        const query = document.getElementById('search-bar').value.toLowerCase();
        const processRows = document.querySelectorAll('[data-process-name]');
        processRows.forEach(row => {
            const processName = row.getAttribute('data-process-name').toLowerCase();
            if (processName.includes(query)) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
        saveFilterSettings();
    }

    let allProcesses = {};
    let isInitialLoad = true;

    async function fetchProcesses() {
        const response = await fetch("{{ url_for('process.get_process') }}");
        const newProcesses = await response.json();
        
        // Always preserve existing metrics when updating process data
        for (const [name, data] of Object.entries(newProcesses)) {
            if (allProcesses[name]) {
                // Preserve existing metrics before overwriting
                const existingMetrics = allProcesses[name].metrics;
                allProcesses[name] = { ...data };
                if (existingMetrics) {
                    allProcesses[name].metrics = existingMetrics;
                }
            } else {
                // New process, just add it
                allProcesses[name] = data;
            }
        }
        
        // Mark initial load as complete
        if (isInitialLoad && Object.keys(allProcesses).length > 0) {
            isInitialLoad = false;
        }
        
        // Apply saved sort if remember filters is enabled
        if (userSettings && userSettings.remember_filters) {
            const savedSort = localStorage.getItem('dashboardSortOption');
            if (savedSort) {
                sortProcesses();
                return;
            }
        }
        
        renderProcesses(Object.entries(allProcesses));
    }

    function getStatusBadgeClass(status) {
        const statusMap = {
            'running': { class: 'bg-success', icon: 'bi-play-circle-fill' },
            'exited': { class: 'bg-secondary', icon: 'bi-stop-circle-fill' },
            'process stopped': { class: 'bg-warning', icon: 'bi-pause-circle-fill' },
            'error': { class: 'bg-danger', icon: 'bi-exclamation-circle-fill' },
            'restarting': { class: 'bg-info', icon: 'bi-arrow-clockwise' }
        };
        const normalized = status.toLowerCase();
        return statusMap[normalized] || { class: 'bg-secondary', icon: 'bi-question-circle-fill' };
    }

    function renderProcesses(processEntries) {
        const grid = document.getElementById('process-grid');
        
        // Only show "no processes" if we've finished initial load and truly have no processes
        if (processEntries.length === 0) {
            if (!isInitialLoad) {
                grid.innerHTML = `
                    <tr>
                        <td colspan="7" class="text-center" style="padding: 40px;">
                            <i class="bi bi-inbox" style="font-size: 48px; color: var(--text-muted);"></i>
                            <p style="color: var(--text-muted); margin-top: 16px;">No processes found</p>
                        </td>
                    </tr>
                `;
            }
            return;
        }
        
        grid.innerHTML = '';

        processEntries.forEach(([name, process]) => {
            const statusInfo = getStatusBadgeClass(process.status);
            
            // Fetch real metrics
            const cpuUsage = process.metrics?.cpu_percent || 0;
            const memUsage = process.metrics?.memory_percent || 0;
            
            const row = `
            <tr data-process-name="${name}">
                <td><code>${name.substring(0, 12)}</code></td>
                <td>${name}</td>
                <td><span class="badge bg-info">${process.type}</span></td>
                <td>
                    <span class="badge ${statusInfo.class}" style="display: flex; align-items: center; gap: 6px; width: fit-content;">
                        <i class="bi ${statusInfo.icon}"></i>
                        ${process.status.charAt(0).toUpperCase() + process.status.slice(1)}
                    </span>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 40px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden;">
                            <div style="width: ${cpuUsage}%; height: 100%; background: ${cpuUsage > 80 ? 'var(--accent-red)' : cpuUsage > 60 ? 'var(--accent-yellow)' : 'var(--accent-green)'};"></div>
                        </div>
                        <span style="font-size: 12px; color: var(--text-secondary);">${cpuUsage}%</span>
                    </div>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 40px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden;">
                            <div style="width: ${memUsage}%; height: 100%; background: ${memUsage > 80 ? 'var(--accent-red)' : memUsage > 60 ? 'var(--accent-yellow)' : 'var(--accent-green)'};"></div>
                        </div>
                        <span style="font-size: 12px; color: var(--text-secondary);">${memUsage}%</span>
                    </div>
                </td>
                <td>
                    <a href="/process/console/${name}" class="btn btn-sm btn-outline-primary">
                        <i class="bi bi-eye"></i> View
                    </a>
                </td>
            </tr>
            `;
            grid.innerHTML += row;
        });
        filterProcesses();
    }

    fetchProcesses();

    function sortProcesses() {
        const sortValue = document.getElementById('sort-select').value;
        let entries = Object.entries(allProcesses);

        if (sortValue === 'alpha') {
            entries.sort((a, b) => a[0].localeCompare(b[0]));
        } else if (sortValue === 'alpha-reverse') {
            entries.sort((a, b) => b[0].localeCompare(a[0]));
        } else if (sortValue === 'created') {
            entries.sort((a, b) => new Date(a[1].created_at) - new Date(b[1].created_at));
        } else if (sortValue === 'created-reverse') {
            entries.sort((a, b) => new Date(b[1].created_at) - new Date(a[1].created_at));
        } else if (sortValue === 'status') {
            entries.sort((a, b) => a[1].status.localeCompare(b[1].status));
        } else if (sortValue === 'status-reverse') {
            entries.sort((a, b) => b[1].status.localeCompare(a[1].status));
        }

        renderProcesses(entries);
        saveFilterSettings();
    }

    // Load user settings when page loads
    loadUserSettings();

    // Fetch real-time metrics for all processes
    async function fetchProcessMetrics() {
        if (!allProcesses || Object.keys(allProcesses).length === 0) return;

        for (const [name, process] of Object.entries(allProcesses)) {
            if (process.status && process.status.toLowerCase() === 'running') {
                try {
                    const response = await fetch(`/process/metrics/${name}`);
                    if (response.ok) {
                        const metrics = await response.json();
                        allProcesses[name].metrics = metrics;
                    } else {
                        console.warn(`Failed to fetch metrics for ${name}: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Failed to fetch metrics for ${name}:`, error);
                }
            }
        }

        // Update metrics in-place without re-rendering the entire table
        for (const [name, process] of Object.entries(allProcesses)) {
            const row = document.querySelector(`tr[data-process-name="${name}"]`);
            if (!row) continue;
            
            const cpuUsage = process.metrics?.cpu_percent || 0;
            const memUsage = process.metrics?.memory_percent || 0;
            
            // Update CPU
            const cpuBar = row.querySelector('td:nth-child(5) div div');
            const cpuText = row.querySelector('td:nth-child(5) span');
            if (cpuBar && cpuText) {
                cpuBar.style.width = `${cpuUsage}%`;
                cpuBar.style.background = cpuUsage > 80 ? 'var(--accent-red)' : cpuUsage > 60 ? 'var(--accent-yellow)' : 'var(--accent-green)';
                cpuText.textContent = `${cpuUsage}%`;
            }
            
            // Update Memory
            const memBar = row.querySelector('td:nth-child(6) div div');
            const memText = row.querySelector('td:nth-child(6) span');
            if (memBar && memText) {
                memBar.style.width = `${memUsage}%`;
                memBar.style.background = memUsage > 80 ? 'var(--accent-red)' : memUsage > 60 ? 'var(--accent-yellow)' : 'var(--accent-green)';
                memText.textContent = `${memUsage}%`;
            }
        }
    }

    // Fetch metrics every 5 seconds
    setInterval(fetchProcessMetrics, 5000);
    // Initial fetch after 1 second
    setTimeout(fetchProcessMetrics, 1000);
</script>
{% endblock content %}
