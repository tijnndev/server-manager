{% extends 'process/process_layout.html' %}

{% block process_content %}
<style>
    .console-output {
        background-color: #333;
        color: white;
        font-family: monospace;
        padding: 15px;
        height: 600px;
        overflow-y: scroll;
        font-size: 13px;
        white-space: pre-wrap;
    }
</style>

<div class="container mt-4">
    
    <h2 class="">Console for {{ process.name }}</h2>
    
    <div class="text-light">
        Status: 
        <span class="server-status text-{{ 'success' if process_status == 'Running' else 'danger' }}">
            <span class="server-status-label">{{ process_status | capitalize }}</span>
        </span>
    </div>
    <div class="text-light mb-4">
        URL: 
        {% if not process.domain %}
        <a href="http://{{ server_ip }}:{{ 8000 + process.port_id}}">http://{{ server_ip }}:{{ 8000 + process.port_id}}</a>
        {% else %}
        <a href="https://{{process.domain}}">{{process.domain}}</a>
        {% endif %}
    </div>


    <div class="text-light mb-4">
        Uptime: 
        <span id="process-uptime">Fetching uptime...</span>
    </div>

    <div class="console-output" id="console-output"></div>

    <!-- Command Input Section -->
    <div class="mt-3 mb-3">
        <div class="input-group">
            <span class="input-group-text bg-dark text-light border-secondary">$</span>
            <input type="text" 
                   class="form-control bg-dark text-light border-secondary" 
                   id="command-input" 
                   placeholder="Enter command to execute in container..."
                   style="font-family: monospace;">
            <button class="btn btn-primary" type="button" onclick="executeCommand()">Execute</button>
            <button class="btn btn-secondary" type="button" onclick="openShell()">Shell</button>
        </div>
        <small class="text-muted">
            Commands will be executed in the container's /app directory. Press Enter to execute.
        </small>
    </div>

    <div class="mt-3 mb-6">
        <button class="btn btn-success mt-2 " onclick="startProcess('{{ process.name }}')">Start</button>
        <button class="btn btn-danger mt-2" onclick="stopProcess('{{ process.name }}')">Stop</button>
        <button class="btn btn-warning mt-2" onclick="restartProcess('{{ process.name }}')">Restart</button>
        <button class="btn btn-info mt-2" onclick="clearLogs('{{ process.name }}')">Clear Logs</button>
    </div>
</div>

<script>
    const consoleOutput = document.getElementById('console-output');
    const commandInput = document.getElementById('command-input');
    const uptimeElement = document.getElementById('process-uptime');
    const startButton = document.querySelector('button[onclick="startProcess(\'{{ process.name }}\')"]');
    const stopButton = document.querySelector('button[onclick="stopProcess(\'{{ process.name }}\')"]');
    const restartButton = document.querySelector('button[onclick="restartProcess(\'{{ process.name }}\')"]');

    async function startConsole() {
        const eventSource = new EventSource(`/process/console/{{ process.name }}/logs`);
        const seenMessages = new Set();
        let isPageActive = true;

        document.addEventListener("visibilitychange", () => {
            isPageActive = !document.hidden;
        });

        eventSource.onmessage = function(event) {
            if (!isPageActive) return;

            const message = event.data.trim();
            if (message && !seenMessages.has(message)) {
                seenMessages.add(message);
                consoleOutput.innerHTML += message + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        };
    }


    async function fetchUptime() {
        setInterval(async () => {
            try {
                const response = await fetch(`/process/console/{{ process.name }}/uptime`);
                if (response.ok) {
                    const data = await response.json();
                    uptimeElement.innerText = data.uptime;
                } else {
                    console.error('Failed to fetch uptime');
                    console.log(await response.text())
                }
            } catch (error) {
                console.error('Error fetching uptime:', error);
            }
        }, 1000);
    }

    startConsole();
    fetchUptime();

    // Add Enter key support for command input
    commandInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            executeCommand();
        }
    });

    async function executeCommand() {
        const command = commandInput.value.trim();
        if (!command) {
            alert('Please enter a command');
            return;
        }

        // Clear the input
        commandInput.value = '';
        
        // Show command in console
        // consoleOutput.innerHTML += `$ ${command}\n`;
        // consoleOutput.scrollTop = consoleOutput.scrollHeight;

        try {
            const response = await fetch(`/process/execute/{{ process.name }}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    command: command,
                    working_dir: '/app',
                    timeout: 30
                })
            });

            const result = await response.json();
            
            if (result.success) {
                // Output will be shown via live log stream automatically
                console.log('Command executed successfully');
            } else {
                // consoleOutput.innerHTML += `[ERROR] ${result.error}\n`;
                // consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        } catch (error) {
            // consoleOutput.innerHTML += `[ERROR] Failed to execute command: ${error.message}\n`;
            // consoleOutput.scrollTop = consoleOutput.scrollHeight;
            // console.error('Execute command error:', error);
        }
    }

    async function openShell() {
        try {
            const response = await fetch(`/process/execute/{{ process.name }}/shell`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    working_dir: '/app',
                    shell: '/bin/bash'
                })
            });

            const result = await response.json();
            
            if (result.success) {
                consoleOutput.innerHTML += `[SHELL] Interactive shell session started (PID: ${result.process_pid})\n`;
                consoleOutput.innerHTML += `[SHELL] Working directory: ${result.working_dir}\n`;
                consoleOutput.innerHTML += `[SHELL] Use 'exit' to close the shell session\n`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            } else {
                consoleOutput.innerHTML += `[ERROR] Failed to open shell: ${result.error}\n`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        } catch (error) {
            consoleOutput.innerHTML += `[ERROR] Failed to open shell: ${error.message}\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            console.error('Open shell error:', error);
        }
    }

    async function startProcess(name) {
    try {
        consoleOutput.innerHTML += `| Process start command received\n`;
        
        const response = await fetch(`{{ url_for('process.start_process_console', name="") }}${name}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            const errorResponse = await response.json(); // Ensure to handle error responses
            alert(`Failed to start process: ${errorResponse.error}`);
            console.log(errorResponse);
            return;
        }

        const responseData = await response.json(); // Parse the JSON only when the response is okay
        if (responseData && responseData.ok) {
            consoleOutput.innerHTML += `| Process started\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            updateProcessStatus('running');
        } else {
            alert('Failed to start process');
            console.log(responseData);
        }
    } catch (error) {
        alert('An error occurred while starting the process');
        console.error('Fetch error:', error);
        console.log(error);
    }
}


    async function stopProcess(name) {
        consoleOutput.innerHTML += `| Process stop command received\n`;
        const response = await fetch(`{{ url_for('process.stop_process_console', name="") }}` + name, { method: 'POST' });
        if (response.ok) {
            consoleOutput.innerHTML += `| Process stopped\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            updateProcessStatus('exited');
        } else {
            const errorMessage = await response.text();
            alert('Failed to stop process: ' + errorMessage);
            console.log('Response Error:', errorMessage);
        }
    }

    async function restartProcess(name) {
        consoleOutput.innerHTML += `| Restarting process...\n`;
        consoleOutput.scrollTop = consoleOutput.scrollHeight;
        updateProcessStatus('restarting');
        
        const stopResponse = await fetch(`{{ url_for('process.stop_process_console', name="") }}` + name, { method: 'POST' });
        if (stopResponse.ok) {
            consoleOutput.innerHTML += `| Process stopped successfully.\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            setTimeout(async () => {
                const startResponse = await fetch(`{{ url_for('process.start_process_console', name="") }}` + name, { method: 'POST' });
                if (startResponse.ok) {
                    consoleOutput.innerHTML += `| Process started successfully.\n`;
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                    updateProcessStatus('running');
                } else {
                    alert('Failed to start process after stopping');
                }
            }, 2000);
        } else {
            alert('Failed to stop process');
        }
    }

    async function clearLogs(name) {
        try {
            const response = await fetch(`/process/clear-logs/${name}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            const result = await response.json();
            
            if (result.success) {
                // Clear the console display
                consoleOutput.innerHTML = '';
                console.log('Logs cleared successfully');
            } else {
                alert(`Failed to clear logs: ${result.error}`);
                console.error('Clear logs error:', result.error);
            }
        } catch (error) {
            alert(`Error clearing logs: ${error.message}`);
            console.error('Clear logs error:', error);
        }
    }

    function updateProcessStatus(status) {
        const statusText = document.querySelector('.server-status');
        const statusLabel = document.querySelector('.server-status-label');

        if (status === 'running') {
            statusText.classList.remove('text-danger', 'text-warning');
            statusText.classList.add('text-success');
            statusLabel.innerText = 'Running';
            changeStartButton(true);
            changeStopButton(false);
            changeRestartButton(false);
        } else if (status === 'restarting') {
            statusText.classList.remove('text-success', 'text-danger');
            statusText.classList.add('text-warning');
            statusLabel.innerText = 'Restarting';
            changeAllButtons(true);
        } else {
            statusText.classList.remove('text-success', 'text-warning');
            statusText.classList.add('text-danger');
            statusLabel.innerText = 'Exited';
            changeStartButton(false);
            changeStopButton(true);
            changeRestartButton(true);
        }
    }

    function checkStatus() {
        let status = `{{ process_status }}`
        if(status == "Running") {
            changeStartButton(true);
            changeStopButton(false);
            changeRestartButton(false);
        } else if(status == "Exited") {
            changeStartButton(false);
            changeStopButton(true);
            changeRestartButton(true);
        }
    }
    checkStatus()

    function changeStartButton(state) {
        startButton.disabled = state;
    }

    function changeStopButton(state) {
        stopButton.disabled = state;
    }

    function changeRestartButton(state) {
        restartButton.disabled = state;
    }

    function changeAllButtons(state) {
        changeStartButton(state);
        changeStopButton(state);
        changeRestartButton(state);
    }
</script>
{% endblock process_content %}
