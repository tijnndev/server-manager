{% extends 'process/process_layout.html' %} 

{% block process_content %}
<div class="row">
    <div class="col-lg-8 mb-3">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span><i class="bi bi-terminal"></i> Console Output</span>
                <div class="btn-group">
                    <button class="btn btn-success btn-sm" id="start-btn" onclick="startProcess('{{ process.name }}')">
                        <i class="bi bi-play-fill"></i> Start
                    </button>
                    <button class="btn btn-danger btn-sm" id="stop-btn" onclick="stopProcess('{{ process.name }}')">
                        <i class="bi bi-stop-fill"></i> Stop
                    </button>
                    <button class="btn btn-warning btn-sm" id="restart-btn" onclick="restartProcess('{{ process.name }}')">
                        <i class="bi bi-arrow-clockwise"></i> Restart
                    </button>
                    <button class="btn btn-info btn-sm" onclick="refreshLogs()">
                        <i class="bi bi-arrow-repeat"></i> Refresh
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="clearLogs('{{ process.name }}')">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
            </div>
            <div class="card-body p-0">
                <div class="console-output" id="console-output"></div>
            </div>
        </div>

        <div class="card mt-3">
            <div class="card-header">
                <i class="bi bi-terminal-plus"></i> Execute Commands
            </div>
            <div class="card-body">
                <div class="input-group" style="position: relative;">
                    <span class="input-group-text bg-dark text-success">$</span>
                    <input
                        type="text"
                        class="form-control"
                        id="command-input"
                        placeholder="Enter command to execute..."
                        style="font-family: monospace"
                        autocomplete="off"
                    />
                    <button class="btn btn-primary" type="button" onclick="executeCommand()" id="execute-btn">
                        Execute
                    </button>
                    <!-- Command autocomplete dropdown -->
                    <div id="command-autocomplete" class="command-autocomplete" style="display: none;"></div>
                </div>
                <small class="text-muted mt-2 d-block">
                    Commands execute in /app directory. 
                    <span class="text-info">↑↓ to navigate history, Tab to autocomplete, Esc to close</span>
                </small>
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card">
            <div class="card-header bg-primary">
                <i class="bi bi-info-circle"></i> Process Information
            </div>
            <div class="card-body">
                <div class="row g-3">
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-muted">Type:</span>
                            <span class="type-indicator">
                                <span id="type-label">{{ process.type | capitalize }}</span>
                            </span>
                        </div>
                    </div>
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-muted">Status:</span>
                            <span class="status-indicator">
                                <span class="status-dot" id="status-dot"></span>
                                <span id="status-label">{{ process_status | capitalize }}</span>
                            </span>
                        </div>
                    </div>
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-muted">Uptime:</span>
                            <span id="process-uptime">Fetching...</span>
                        </div>
                    </div>
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-muted">URL:</span>
                            <span>
                                {% if not process.domain %}
                                <a href="http://{{ server_ip }}:{{ 8000 + process.port_id}}" target="_blank" class="text-decoration-none">
                                    <i class="bi bi-box-arrow-up-right"></i>
                                </a>
                                {% else %}
                                <a href="https://{{process.domain}}" target="_blank" class="text-decoration-none">
                                    <i class="bi bi-box-arrow-up-right"></i>
                                </a>
                                {% endif %}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mt-3">
            <div class="card-header bg-success">
                <i class="bi bi-graph-up"></i> Resource Usage
            </div>
            <div class="card-body">
                <div class="progress-item">
                    <div class="progress-header">
                        <span>CPU</span>
                        <span class="fw-bold" id="process-cpu">0%</span>
                    </div>
                    <div class="progress">
                        <div class="progress-bar" id="cpu-progress" style="width: 0%"></div>
                    </div>
                </div>
                <div class="progress-item">
                    <div class="progress-header">
                        <span>Memory</span>
                        <span class="fw-bold" id="process-memory">0 MB</span>
                    </div>
                    <div class="progress">
                        <div class="progress-bar bg-warning" id="memory-progress" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="loading-overlay" id="loading-overlay">
    <div class="d-flex align-items-center">
        <div class="spinner-border text-primary me-2" role="status"></div>
        <span id="loading-text">Processing...</span>
    </div>
</div>

<style>
.console-output {
    background-color: #1a1a1a;
    color: #e0e0e0;
    font-family: "Consolas", "Monaco", "Courier New", monospace;
    padding: 20px;
    height: 400px;
    overflow-y: auto;
    font-size: 14px;
    white-space: pre-wrap;
    word-wrap: break-word;
    border: none;
}

.console-output::-webkit-scrollbar {
    width: 8px;
}

.console-output::-webkit-scrollbar-track {
    background: #2a2a2a;
}

.console-output::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
}

.console-output::-webkit-scrollbar-thumb:hover {
    background: #666;
}

.status-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: pulse 2s infinite;
}

.status-dot.running {
    background-color: #28a745;
}

.status-dot.stopped {
    background-color: #dc3545;
}

.status-dot.restarting {
    background-color: #ffc107;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.loading-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}
</style>

<script>
  const consoleOutput = document.getElementById("console-output");
  let commandInput = document.getElementById("command-input");
  const uptimeElement = document.getElementById("process-uptime");
  const statusDot = document.getElementById("status-dot");
  const statusLabel = document.getElementById("status-label");
  const loadingOverlay = document.getElementById("loading-overlay");
  const loadingText = document.getElementById("loading-text");

  const seenMessages = new Set();

  let eventSource = null;
  let uptimeInterval = null;
  let isPageActive = true;
  let lastLogTimestamp = Date.now();
  let userSettings = null;
  let currentStatus = "{{ process_status|lower }}";

  // Command autocomplete state
  let commandHistory = [];
  let historyIndex = -1;
  let currentInput = '';
  let autocompleteVisible = false;
  let selectedSuggestionIndex = -1;
  const autocompleteDropdown = document.getElementById('command-autocomplete');

  // Common commands for autocomplete suggestions
  const commonCommands = [
    { cmd: 'ls', desc: 'List directory contents', icon: 'bi-list-ul' },
    { cmd: 'ls -la', desc: 'List all files with details', icon: 'bi-list-ul' },
    { cmd: 'cd', desc: 'Change directory', icon: 'bi-folder' },
    { cmd: 'pwd', desc: 'Print working directory', icon: 'bi-folder2-open' },
    { cmd: 'cat', desc: 'Display file contents', icon: 'bi-file-text' },
    { cmd: 'tail -f', desc: 'Follow file changes', icon: 'bi-file-earmark-text' },
    { cmd: 'grep', desc: 'Search text patterns', icon: 'bi-search' },
    { cmd: 'find', desc: 'Search for files', icon: 'bi-search' },
    { cmd: 'ps aux', desc: 'List running processes', icon: 'bi-cpu' },
    { cmd: 'top', desc: 'Display system tasks', icon: 'bi-speedometer2' },
    { cmd: 'df -h', desc: 'Disk space usage', icon: 'bi-hdd' },
    { cmd: 'free -m', desc: 'Memory usage', icon: 'bi-memory' },
    { cmd: 'netstat -tuln', desc: 'Show network connections', icon: 'bi-network' },
    { cmd: 'curl', desc: 'Transfer data from URL', icon: 'bi-download' },
    { cmd: 'wget', desc: 'Download files', icon: 'bi-cloud-download' },
    { cmd: 'git status', desc: 'Show git status', icon: 'bi-git' },
    { cmd: 'git log', desc: 'Show commit history', icon: 'bi-clock-history' },
    { cmd: 'git pull', desc: 'Pull latest changes', icon: 'bi-arrow-down-circle' },
    { cmd: 'npm install', desc: 'Install npm packages', icon: 'bi-box-seam' },
    { cmd: 'npm start', desc: 'Start npm script', icon: 'bi-play-circle' },
    { cmd: 'npm run', desc: 'Run npm script', icon: 'bi-play' },
    { cmd: 'pip install', desc: 'Install Python package', icon: 'bi-box-seam' },
    { cmd: 'python', desc: 'Run Python interpreter', icon: 'bi-code-slash' },
    { cmd: 'node', desc: 'Run Node.js', icon: 'bi-code-square' },
    { cmd: 'docker ps', desc: 'List containers', icon: 'bi-box' },
    { cmd: 'docker logs', desc: 'View container logs', icon: 'bi-file-text' },
    { cmd: 'systemctl status', desc: 'Check service status', icon: 'bi-gear' },
    { cmd: 'chmod', desc: 'Change file permissions', icon: 'bi-shield-lock' },
    { cmd: 'chown', desc: 'Change file owner', icon: 'bi-person-badge' },
    { cmd: 'mkdir', desc: 'Create directory', icon: 'bi-folder-plus' },
    { cmd: 'rm', desc: 'Remove files', icon: 'bi-trash' },
    { cmd: 'mv', desc: 'Move/rename files', icon: 'bi-arrow-left-right' },
    { cmd: 'cp', desc: 'Copy files', icon: 'bi-files' },
    { cmd: 'echo', desc: 'Print text', icon: 'bi-chat-text' },
    { cmd: 'env', desc: 'Show environment variables', icon: 'bi-list-check' },
  ];

  // Load command history from localStorage
  function loadCommandHistory() {
    try {
      const saved = localStorage.getItem('command_history_{{ process.name }}');
      if (saved) {
        commandHistory = JSON.parse(saved);
      }
    } catch (error) {
      console.error('Failed to load command history:', error);
    }
  }

  // Save command history to localStorage
  function saveCommandHistory() {
    try {
      // Keep only last 50 commands
      const recentHistory = commandHistory.slice(-50);
      localStorage.setItem('command_history_{{ process.name }}', JSON.stringify(recentHistory));
    } catch (error) {
      console.error('Failed to save command history:', error);
    }
  }

  // Add command to history
  function addToHistory(command) {
    // Don't add duplicate consecutive commands
    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command) {
      commandHistory.push(command);
      saveCommandHistory();
    }
  }

  // Show autocomplete suggestions
  function showAutocomplete(query) {
    const suggestions = getSuggestions(query);
    
    if (suggestions.length === 0) {
      hideAutocomplete();
      return;
    }

    let html = '';
    let currentCategory = '';

    suggestions.forEach((suggestion, index) => {
      if (suggestion.category !== currentCategory) {
        currentCategory = suggestion.category;
        html += `<div class="autocomplete-category">${currentCategory}</div>`;
      }

      html += `
        <div class="autocomplete-item" data-index="${index}" data-command="${suggestion.cmd}">
          <i class="${suggestion.icon || 'bi-terminal'} autocomplete-item-icon"></i>
          <span class="autocomplete-item-text">${highlightMatch(suggestion.cmd, query)}</span>
          ${suggestion.desc ? `<span class="autocomplete-item-description">${suggestion.desc}</span>` : ''}
        </div>
      `;
    });

    autocompleteDropdown.innerHTML = html;
    autocompleteDropdown.style.display = 'block';
    autocompleteVisible = true;
    selectedSuggestionIndex = -1;

    // Add click listeners to items
    document.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('click', () => {
        commandInput.value = item.dataset.command;
        hideAutocomplete();
        commandInput.focus();
      });
    });
  }

  // Hide autocomplete
  function hideAutocomplete() {
    autocompleteDropdown.style.display = 'none';
    autocompleteVisible = false;
    selectedSuggestionIndex = -1;
  }

  // Get suggestions based on query
  function getSuggestions(query) {
    if (!query || query.trim() === '') {
      return [];
    }

    const lowerQuery = query.toLowerCase();
    const suggestions = [];

    // Add matching history items
    const historyMatches = commandHistory
      .filter(cmd => cmd.toLowerCase().includes(lowerQuery))
      .reverse()
      .slice(0, 5)
      .map(cmd => ({
        cmd: cmd,
        desc: 'From history',
        icon: 'bi-clock-history',
        category: 'Recent Commands'
      }));

    // Add matching common commands
    const commandMatches = commonCommands
      .filter(item => item.cmd.toLowerCase().includes(lowerQuery))
      .slice(0, 10)
      .map(item => ({
        ...item,
        category: 'Common Commands'
      }));

    return [...historyMatches, ...commandMatches];
  }

  // Highlight matching text
  function highlightMatch(text, query) {
    if (!query) return text;
    const index = text.toLowerCase().indexOf(query.toLowerCase());
    if (index === -1) return text;
    
    const before = text.substring(0, index);
    const match = text.substring(index, index + query.length);
    const after = text.substring(index + query.length);
    
    return `${before}<strong>${match}</strong>${after}`;
  }

  // Navigate autocomplete with arrow keys
  function navigateAutocomplete(direction) {
    const items = document.querySelectorAll('.autocomplete-item');
    if (items.length === 0) return;

    // Remove active class from current item
    if (selectedSuggestionIndex >= 0) {
      items[selectedSuggestionIndex].classList.remove('active');
    }

    // Update index
    if (direction === 'down') {
      selectedSuggestionIndex = (selectedSuggestionIndex + 1) % items.length;
    } else if (direction === 'up') {
      selectedSuggestionIndex = selectedSuggestionIndex <= 0 ? items.length - 1 : selectedSuggestionIndex - 1;
    }

    // Add active class to new item
    items[selectedSuggestionIndex].classList.add('active');
    items[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
  }

  // Select current autocomplete suggestion
  function selectSuggestion() {
    const items = document.querySelectorAll('.autocomplete-item');
    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < items.length) {
      commandInput.value = items[selectedSuggestionIndex].dataset.command;
      hideAutocomplete();
      return true;
    }
    return false;
  }

  // Navigate command history
  function navigateHistory(direction) {
    if (commandHistory.length === 0) return;

    if (historyIndex === -1) {
      currentInput = commandInput.value;
    }

    if (direction === 'up') {
      if (historyIndex < commandHistory.length - 1) {
        historyIndex++;
        commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
      }
    } else if (direction === 'down') {
      if (historyIndex > 0) {
        historyIndex--;
        commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
      } else if (historyIndex === 0) {
        historyIndex = -1;
        commandInput.value = currentInput;
      }
    }
  }

  // Load user preferences and apply console settings
  async function loadConsolePreferences() {
    try {
      const response = await fetch("{{ url_for('settings.get_preferences') }}");
      const data = await response.json();
      userSettings = data;
      
      // Apply console font size
      if (userSettings.console_font_size) {
        consoleOutput.style.fontSize = userSettings.console_font_size + 'px';
      }
      
      // Apply word wrap setting
      if (userSettings.console_word_wrap === false) {
        consoleOutput.style.whiteSpace = 'pre';
        consoleOutput.style.overflowX = 'auto';
      } else {
        consoleOutput.style.whiteSpace = 'pre-wrap';
        consoleOutput.style.overflowX = 'hidden';
      }
    } catch (error) {
      console.error("Failed to load console preferences:", error);
    }
  }

  // Page visibility handling
  document.addEventListener("visibilitychange", () => {
    isPageActive = !document.hidden;
    if (isPageActive) {
      refreshLogs(false);
    }
  });

  // Initialize console
  function initializeConsole() {
    loadConsolePreferences();
    loadCommandHistory();
    startConsole();
    startUptimeUpdates();
  updateProcessStatus("{{ process_status }}");

    // Add command input event listeners
    commandInput.addEventListener("keydown", function (event) {
      if (event.key === "Enter") {
        if (autocompleteVisible && selectedSuggestionIndex >= 0) {
          // Select autocomplete suggestion
          event.preventDefault();
          selectSuggestion();
        } else {
          // Execute command
          executeCommand();
        }
      } else if (event.key === "ArrowUp") {
        event.preventDefault();
        if (autocompleteVisible) {
          navigateAutocomplete('up');
        } else {
          navigateHistory('up');
        }
      } else if (event.key === "ArrowDown") {
        event.preventDefault();
        if (autocompleteVisible) {
          navigateAutocomplete('down');
        } else {
          navigateHistory('down');
        }
      } else if (event.key === "Tab") {
        if (autocompleteVisible) {
          event.preventDefault();
          selectSuggestion();
        }
      } else if (event.key === "Escape") {
        if (autocompleteVisible) {
          event.preventDefault();
          hideAutocomplete();
        }
      }
    });

    // Show autocomplete on input
    commandInput.addEventListener("input", function (event) {
      historyIndex = -1; // Reset history navigation
      const query = commandInput.value.trim();
      
      if (query.length > 0) {
        showAutocomplete(query);
      } else {
        hideAutocomplete();
      }
    });

    // Hide autocomplete when clicking outside
    document.addEventListener("click", function (event) {
      if (!commandInput.contains(event.target) && !autocompleteDropdown.contains(event.target)) {
        hideAutocomplete();
      }
    });
  }

  function showLoading(message = "Processing...") {
    loadingText.textContent = message;
    loadingOverlay.style.display = "flex";
  }

  function hideLoading() {
    loadingOverlay.style.display = "none";
  }

  function addLogMessage(message, type = "info") {
    const timestamp = new Date().toLocaleTimeString();
    const prefix =
      type === "error" ? "[ERROR]" : type === "system" ? "[SYSTEM]" : "";
    
    // Check if timestamps should be shown
    const showTimestamp = userSettings && userSettings.show_timestamps !== false;
    const timestampStr = showTimestamp ? `[${timestamp}] ` : '';
    const logLine = `${timestampStr}${prefix} ${message}`;

    // Create a new div for the line
    const lineDiv = document.createElement("div");
    lineDiv.textContent = logLine;
    consoleOutput.appendChild(lineDiv);

    // Remove old lines if over 150
    while (consoleOutput.childNodes.length > 150) {
      consoleOutput.removeChild(consoleOutput.firstChild);
    }

    consoleOutput.scrollTop = consoleOutput.scrollHeight;
    lastLogTimestamp = Date.now();
  }

  function startConsole() {
    if (eventSource) {
      eventSource.close();
    }

    try {
      eventSource = new EventSource(`/process/console/{{ process.name }}/logs`);

      eventSource.onmessage = function (event) {
        if (!isPageActive) return;

        const message = event.data.trim();
        if (message && !seenMessages.has(message)) {
            seenMessages.add(message);
            consoleOutput.innerHTML += message + "\n";
      const lowerMessage = message.toLowerCase();
      if (lowerMessage.includes('build process finished') || lowerMessage.includes('build completed')) {
        updateProcessStatus('running');
      }
      if (lowerMessage.includes('stopped successfully') || lowerMessage.includes('process stopped') || lowerMessage.includes('container stopped')) {
        updateProcessStatus('exited');
      }
      if (lowerMessage.includes('process started successfully') || lowerMessage.includes('server started')) {
        updateProcessStatus('running');
      }
            
            // Increment new logs counter if not auto-scrolling
            if (enhancedConsole && !enhancedConsole.autoScroll) {
                enhancedConsole.incrementNewLogs();
            } else {
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
            
            lastLogTimestamp = Date.now();
        }
    };
    eventSource.onerror = function (event) {
        // Silently handle reconnection without showing error messages
        // EventSource automatically reconnects, so we don't need to do anything
        console.log("EventSource reconnecting...");
      };

      eventSource.onopen = function (event) {
        console.log("Log stream connected");
      };
    } catch (error) {
      console.error("Failed to start console:", error);
      addLogMessage("Failed to connect to log stream", "error");
    }
  }

  function refreshLogs(showLog = true) {
    if(showLog) addLogMessage("Refreshing logs...", "system");
    startConsole();
  }

  function startUptimeUpdates() {
    if (uptimeInterval) {
      clearInterval(uptimeInterval);
    }

    uptimeInterval = setInterval(async () => {
      try {
        const response = await fetch(
          `/process/console/{{ process.name }}/uptime`
        );
        if (response.ok) {
          const data = await response.json();
          uptimeElement.textContent = data.uptime || "N/A";
        } else {
          uptimeElement.textContent = "Unavailable";
        }
      } catch (error) {
        console.error("Error fetching uptime:", error);
        uptimeElement.textContent = "Error";
      }
    }, 2000);
  }

  async function executeCommand() {
    commandInput = document.getElementById("command-input");
    const command = commandInput.value.trim();
    if (!command) {
      showWarning("Please enter a command");
      return;
    }

    // Add to history before executing
    addToHistory(command);
    historyIndex = -1;
    hideAutocomplete();

    const executeBtn = document.getElementById("execute-btn");
    executeBtn.disabled = true;
    executeBtn.innerHTML =
      '<i class="fas fa-spinner fa-spin"></i> Executing...';

    // Track command execution
    if (enhancedConsole) {
      enhancedConsole.trackCommandExecution(command);
    }
    const startTime = Date.now();

    try {
      const response = await fetch(`/process/execute/{{ process.name }}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          command: command,
          working_dir: "/app",
          timeout: 30,
        }),
      });

      const result = await response.json();
      const duration = ((Date.now() - startTime) / 1000).toFixed(2);

      if (!result.success) {
        showError(`Command failed: ${result.error || 'Unknown error'}`);
        commandInput.value = "";
      } else {
        showSuccess(`Command executed successfully (${duration}s)`);
      }
    } catch (error) {
      addLogMessage(`Failed to execute command: ${error.message}`, "error");
      showError(`Failed to execute command: ${error.message}`);
      commandInput.value = "";
    } finally {
      executeBtn.disabled = false;
      executeBtn.innerHTML = "Execute";
      commandInput.value = "";
    }
  }

  async function startProcess(name) {
    showLoading("Starting process...");
    updateProcessStatus("starting");
    addLogMessage("Process start command received", "system");

    try {
      console.log(name)
      const response = await fetch(
        `{{ url_for('process.start_process_console', name="") }}${name}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      const result = await response.json();

      if (response.ok && result.ok) {
        addLogMessage("Process started successfully", "system");
        updateProcessStatus("running");
        showSuccess(`Process "${name}" started successfully`);

        // Refresh logs after starting
        setTimeout(() => {
          refreshLogs();
        }, 1000);
      } else {
        const errorMsg = result.error || "Unknown error occurred";
        addLogMessage(`Failed to start process: ${errorMsg}`, "error");
        updateProcessStatus("exited");
        showError(`Failed to start process: ${errorMsg}`);
      }
    } catch (error) {
      addLogMessage(`Error starting process: ${error.message}`, "error");
      updateProcessStatus("exited");
      showError(`Error starting process: ${error.message}`);
    } finally {
      hideLoading();
    }
  }

  async function stopProcess(name) {
    showLoading("Stopping process...");
    updateProcessStatus("stopping");
    addLogMessage("Process stop command received", "system");

    try {
      const response = await fetch(
        `{{ url_for('process.stop_process_console', name="") }}${name}`,
        {
          method: "POST",
        }
      );

      if (response.ok) {
        addLogMessage("Process stopped successfully", "system");
        updateProcessStatus("exited");
        showSuccess(`Process "${name}" stopped successfully`);

        // Refresh logs after stopping
        setTimeout(() => {
          refreshLogs();
        }, 1000);
      } else {
        const errorMessage = await response.text();
        addLogMessage(`Failed to stop process: ${errorMessage}`, "error");
        showError(`Failed to stop process: ${errorMessage}`);
      }
    } catch (error) {
      addLogMessage(`Error stopping process: ${error.message}`, "error");
      showError(`Error stopping process: ${error.message}`);
    } finally {
      hideLoading();
    }
  }

  async function restartProcess(name) {
    showLoading("Restarting process...");
    updateProcessStatus("restarting");
    addLogMessage("Restarting process...", "system");

    try {
      // Stop the process first
      const stopResponse = await fetch(
        `{{ url_for('process.stop_process_console', name="") }}${name}`,
        {
          method: "POST",
        }
      );

      if (stopResponse.ok) {
        addLogMessage("Process stopped, starting again...", "system");

        // Wait a moment before starting
        setTimeout(async () => {
          try {
            const startResponse = await fetch(
              `{{ url_for('process.start_process_console', name="") }}${name}`,
              {
                method: "POST",
              }
            );

            if (startResponse.ok) {
              addLogMessage("Process restarted successfully", "system");
              updateProcessStatus("running");

              // Refresh logs after restarting
              setTimeout(() => {
                refreshLogs();
              }, 1000);
            } else {
              addLogMessage("Failed to start process after stopping", "error");
              updateProcessStatus("exited");
            }
          } catch (error) {
            addLogMessage(`Error starting process: ${error.message}`, "error");
            updateProcessStatus("exited");
          } finally {
            hideLoading();
          }
        }, 2000);
      } else {
        addLogMessage("Failed to stop process for restart", "error");
        hideLoading();
      }
    } catch (error) {
      addLogMessage(`Error restarting process: ${error.message}`, "error");
      updateProcessStatus("exited");
      hideLoading();
    }
  }

  async function clearLogs(name) {
    if (!confirm("Are you sure you want to clear all logs?")) {
      return;
    }

    showLoading("Clearing logs...");

    try {
      const response = await fetch(`/process/clear-logs/${name}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      if (result.success) {
        consoleOutput.innerHTML = "";
        seenMessages.clear();
        addLogMessage("Logs cleared successfully", "system");
        refreshLogs();
      } else {
        addLogMessage(`Failed to clear logs: ${result.error}`, "error");
      }
    } catch (error) {
      addLogMessage(`Error clearing logs: ${error.message}`, "error");
    } finally {
      hideLoading();
    }
  }

  function updateProcessStatus(status) {
    const normalized = (status || '').toString().toLowerCase();
    currentStatus = normalized;
    updateUIBasedOnStatus(normalized);
    statusLabel.textContent = normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }

  function updateUIBasedOnStatus(status) {
    const startBtn = document.getElementById("start-btn");
    const stopBtn = document.getElementById("stop-btn");
    const restartBtn = document.getElementById("restart-btn");

    // Remove all status classes
    statusDot.className = "status-dot";

    switch ((status || '').toLowerCase()) {
      case "running":
        statusDot.classList.add("running");
        startBtn.disabled = true;
        stopBtn.disabled = false;
        restartBtn.disabled = false;
        break;
      case "starting":
      case "restarting":
      case "stopping":
        statusDot.classList.add("restarting");
        startBtn.disabled = true;
        stopBtn.disabled = true;
        restartBtn.disabled = true;
        break;
      default: // exited, stopped, etc.
        statusDot.classList.add("stopped");
        startBtn.disabled = false;
        stopBtn.disabled = true;
        restartBtn.disabled = true;
        break;
    }
  }

  // Clean up resources when page is unloaded
  window.addEventListener("beforeunload", function () {
    if (eventSource) {
      eventSource.close();
    }
    if (uptimeInterval) {
      clearInterval(uptimeInterval);
    }
  });

  // Fetch and update process metrics (CPU, Memory)
  async function updateProcessMetrics() {
    try {
      const response = await fetch(`/process/metrics/{{ process.name }}`);
      if (response.ok) {
        const metrics = await response.json();

        const normalizedStatus = (metrics.status || '').toLowerCase();
        const mappedStatus = normalizedStatus === 'stopped' ? 'exited' : normalizedStatus;
        if (mappedStatus && mappedStatus !== currentStatus) {
          updateProcessStatus(mappedStatus);
        }
        
        if (metrics.status === 'running') {
          // Update CPU
          const cpuPercent = metrics.cpu_percent || 0;
          document.getElementById('process-cpu').textContent = `${cpuPercent}%`;
          const cpuProgress = document.getElementById('cpu-progress');
          cpuProgress.style.width = `${Math.min(cpuPercent, 100)}%`;
          
          // Color based on usage
          if (cpuPercent > 80) {
            cpuProgress.style.backgroundColor = 'var(--accent-red)';
          } else if (cpuPercent > 60) {
            cpuProgress.style.backgroundColor = 'var(--accent-yellow)';
          } else {
            cpuProgress.style.backgroundColor = 'var(--accent-green)';
          }
          
          // Update Memory
          const memPercent = metrics.memory_percent || 0;
          const memMb = metrics.memory_mb || 0;
          document.getElementById('process-memory').textContent = `${memMb.toFixed(1)} MB (${memPercent}%)`;
          const memProgress = document.getElementById('memory-progress');
          memProgress.style.width = `${Math.min(memPercent, 100)}%`;
          
          // Color based on usage
          if (memPercent > 80) {
            memProgress.style.backgroundColor = 'var(--accent-red)';
          } else if (memPercent > 60) {
            memProgress.style.backgroundColor = 'var(--accent-yellow)';
          } else {
            memProgress.style.backgroundColor = 'var(--accent-green)';
          }
        }
      }
    } catch (error) {
      console.error('Failed to fetch process metrics:', error);
    }
  }

  // Update metrics every 3 seconds
  setInterval(updateProcessMetrics, 3000);
  // Initial fetch after 1 second
  setTimeout(updateProcessMetrics, 1000);

  // Initialize everything when page loads
  document.addEventListener("DOMContentLoaded", function () {
    initializeConsole();
  });

  // Fallback initialization
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeConsole);
  } else {
    initializeConsole();
  }
</script>
{% endblock process_content %}
